/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-compiler-runtime@0.0.0-experimental-22c6e49-20241219_react@19.0.0";
exports.ids = ["vendor-chunks/react-compiler-runtime@0.0.0-experimental-22c6e49-20241219_react@19.0.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/react-compiler-runtime@0.0.0-experimental-22c6e49-20241219_react@19.0.0/node_modules/react-compiler-runtime/dist/index.js":
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-compiler-runtime@0.0.0-experimental-22c6e49-20241219_react@19.0.0/node_modules/react-compiler-runtime/dist/index.js ***!
  \******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @lightSyntaxTransform\n * @noflow\n * @nolint\n * @preventMunge\n * @preserve-invariant-messages\n */\n\n\"use no memo\";'use strict';\n\nvar React = __webpack_require__(/*! react */ \"(rsc)/./node_modules/.pnpm/next@15.2.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js\");\n\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () { return e[k]; }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);\n\nvar _a, _b;\nconst { useRef, useEffect, isValidElement } = React__namespace;\nconst ReactSecretInternals = (_a = React__namespace.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) !== null && _a !== void 0 ? _a : React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nconst $empty = Symbol.for('react.memo_cache_sentinel');\nconst c = typeof ((_b = React__namespace.__COMPILER_RUNTIME) === null || _b === void 0 ? void 0 : _b.c) === 'function'\n    ?\n        React__namespace.__COMPILER_RUNTIME.c\n    : function c(size) {\n        return React__namespace.useMemo(() => {\n            const $ = new Array(size);\n            for (let ii = 0; ii < size; ii++) {\n                $[ii] = $empty;\n            }\n            $[$empty] = true;\n            return $;\n        }, []);\n    };\nconst LazyGuardDispatcher = {};\n[\n    'readContext',\n    'useCallback',\n    'useContext',\n    'useEffect',\n    'useImperativeHandle',\n    'useInsertionEffect',\n    'useLayoutEffect',\n    'useMemo',\n    'useReducer',\n    'useRef',\n    'useState',\n    'useDebugValue',\n    'useDeferredValue',\n    'useTransition',\n    'useMutableSource',\n    'useSyncExternalStore',\n    'useId',\n    'unstable_isNewReconciler',\n    'getCacheSignal',\n    'getCacheForType',\n    'useCacheRefresh',\n].forEach(name => {\n    LazyGuardDispatcher[name] = () => {\n        throw new Error(`[React] Unexpected React hook call (${name}) from a React compiled function. ` +\n            \"Check that all hooks are called directly and named according to convention ('use[A-Z]') \");\n    };\n});\nlet originalDispatcher = null;\nLazyGuardDispatcher['useMemoCache'] = (count) => {\n    if (originalDispatcher == null) {\n        throw new Error('React Compiler internal invariant violation: unexpected null dispatcher');\n    }\n    else {\n        return originalDispatcher.useMemoCache(count);\n    }\n};\nvar GuardKind;\n(function (GuardKind) {\n    GuardKind[GuardKind[\"PushGuardContext\"] = 0] = \"PushGuardContext\";\n    GuardKind[GuardKind[\"PopGuardContext\"] = 1] = \"PopGuardContext\";\n    GuardKind[GuardKind[\"PushExpectHook\"] = 2] = \"PushExpectHook\";\n    GuardKind[GuardKind[\"PopExpectHook\"] = 3] = \"PopExpectHook\";\n})(GuardKind || (GuardKind = {}));\nfunction setCurrent(newDispatcher) {\n    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;\n    return ReactSecretInternals.ReactCurrentDispatcher.current;\n}\nconst guardFrames = [];\nfunction $dispatcherGuard(kind) {\n    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;\n    if (kind === GuardKind.PushGuardContext) {\n        guardFrames.push(curr);\n        if (guardFrames.length === 1) {\n            originalDispatcher = curr;\n        }\n        if (curr === LazyGuardDispatcher) {\n            throw new Error(`[React] Unexpected call to custom hook or component from a React compiled function. ` +\n                \"Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') \" +\n                'and (2) components are returned as JSX instead of being directly invoked.');\n        }\n        setCurrent(LazyGuardDispatcher);\n    }\n    else if (kind === GuardKind.PopGuardContext) {\n        const lastFrame = guardFrames.pop();\n        if (lastFrame == null) {\n            throw new Error('React Compiler internal error: unexpected null in guard stack');\n        }\n        if (guardFrames.length === 0) {\n            originalDispatcher = null;\n        }\n        setCurrent(lastFrame);\n    }\n    else if (kind === GuardKind.PushExpectHook) {\n        guardFrames.push(curr);\n        setCurrent(originalDispatcher);\n    }\n    else if (kind === GuardKind.PopExpectHook) {\n        const lastFrame = guardFrames.pop();\n        if (lastFrame == null) {\n            throw new Error('React Compiler internal error: unexpected null in guard stack');\n        }\n        setCurrent(lastFrame);\n    }\n    else {\n        throw new Error('React Compiler internal error: unreachable block' + kind);\n    }\n}\nfunction $reset($) {\n    for (let ii = 0; ii < $.length; ii++) {\n        $[ii] = $empty;\n    }\n}\nfunction $makeReadOnly() {\n    throw new Error('TODO: implement $makeReadOnly in react-compiler-runtime');\n}\nconst renderCounterRegistry = new Map();\nfunction clearRenderCounterRegistry() {\n    for (const counters of renderCounterRegistry.values()) {\n        counters.forEach(counter => {\n            counter.count = 0;\n        });\n    }\n}\nfunction registerRenderCounter(name, val) {\n    let counters = renderCounterRegistry.get(name);\n    if (counters == null) {\n        counters = new Set();\n        renderCounterRegistry.set(name, counters);\n    }\n    counters.add(val);\n}\nfunction removeRenderCounter(name, val) {\n    const counters = renderCounterRegistry.get(name);\n    if (counters == null) {\n        return;\n    }\n    counters.delete(val);\n}\nfunction useRenderCounter(name) {\n    const val = useRef(null);\n    if (val.current != null) {\n        val.current.count += 1;\n    }\n    useEffect(() => {\n        if (val.current == null) {\n            const counter = { count: 0 };\n            registerRenderCounter(name, counter);\n            val.current = counter;\n        }\n        return () => {\n            if (val.current !== null) {\n                removeRenderCounter(name, val.current);\n            }\n        };\n    });\n}\nconst seenErrors = new Set();\nfunction $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {\n    function error(l, r, path, depth) {\n        const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;\n        if (seenErrors.has(str)) {\n            return;\n        }\n        seenErrors.add(str);\n        console.error(str);\n    }\n    const depthLimit = 2;\n    function recur(oldValue, newValue, path, depth) {\n        if (depth > depthLimit) {\n            return;\n        }\n        else if (oldValue === newValue) {\n            return;\n        }\n        else if (typeof oldValue !== typeof newValue) {\n            error(`type ${typeof oldValue}`, `type ${typeof newValue}`, path, depth);\n        }\n        else if (typeof oldValue === 'object') {\n            const oldArray = Array.isArray(oldValue);\n            const newArray = Array.isArray(newValue);\n            if (oldValue === null && newValue !== null) {\n                error('null', `type ${typeof newValue}`, path, depth);\n            }\n            else if (newValue === null) {\n                error(`type ${typeof oldValue}`, 'null', path, depth);\n            }\n            else if (oldValue instanceof Map) {\n                if (!(newValue instanceof Map)) {\n                    error(`Map instance`, `other value`, path, depth);\n                }\n                else if (oldValue.size !== newValue.size) {\n                    error(`Map instance with size ${oldValue.size}`, `Map instance with size ${newValue.size}`, path, depth);\n                }\n                else {\n                    for (const [k, v] of oldValue) {\n                        if (!newValue.has(k)) {\n                            error(`Map instance with key ${k}`, `Map instance without key ${k}`, path, depth);\n                        }\n                        else {\n                            recur(v, newValue.get(k), `${path}.get(${k})`, depth + 1);\n                        }\n                    }\n                }\n            }\n            else if (newValue instanceof Map) {\n                error('other value', `Map instance`, path, depth);\n            }\n            else if (oldValue instanceof Set) {\n                if (!(newValue instanceof Set)) {\n                    error(`Set instance`, `other value`, path, depth);\n                }\n                else if (oldValue.size !== newValue.size) {\n                    error(`Set instance with size ${oldValue.size}`, `Set instance with size ${newValue.size}`, path, depth);\n                }\n                else {\n                    for (const v of newValue) {\n                        if (!oldValue.has(v)) {\n                            error(`Set instance without element ${v}`, `Set instance with element ${v}`, path, depth);\n                        }\n                    }\n                }\n            }\n            else if (newValue instanceof Set) {\n                error('other value', `Set instance`, path, depth);\n            }\n            else if (oldArray || newArray) {\n                if (oldArray !== newArray) {\n                    error(`type ${oldArray ? 'array' : 'object'}`, `type ${newArray ? 'array' : 'object'}`, path, depth);\n                }\n                else if (oldValue.length !== newValue.length) {\n                    error(`array with length ${oldValue.length}`, `array with length ${newValue.length}`, path, depth);\n                }\n                else {\n                    for (let ii = 0; ii < oldValue.length; ii++) {\n                        recur(oldValue[ii], newValue[ii], `${path}[${ii}]`, depth + 1);\n                    }\n                }\n            }\n            else if (isValidElement(oldValue) || isValidElement(newValue)) {\n                if (isValidElement(oldValue) !== isValidElement(newValue)) {\n                    error(`type ${isValidElement(oldValue) ? 'React element' : 'object'}`, `type ${isValidElement(newValue) ? 'React element' : 'object'}`, path, depth);\n                }\n                else if (oldValue.type !== newValue.type) {\n                    error(`React element of type ${oldValue.type}`, `React element of type ${newValue.type}`, path, depth);\n                }\n                else {\n                    recur(oldValue.props, newValue.props, `[props of ${path}]`, depth + 1);\n                }\n            }\n            else {\n                for (const key in newValue) {\n                    if (!(key in oldValue)) {\n                        error(`object without key ${key}`, `object with key ${key}`, path, depth);\n                    }\n                }\n                for (const key in oldValue) {\n                    if (!(key in newValue)) {\n                        error(`object with key ${key}`, `object without key ${key}`, path, depth);\n                    }\n                    else {\n                        recur(oldValue[key], newValue[key], `${path}.${key}`, depth + 1);\n                    }\n                }\n            }\n        }\n        else if (typeof oldValue === 'function') {\n            return;\n        }\n        else if (isNaN(oldValue) || isNaN(newValue)) {\n            if (isNaN(oldValue) !== isNaN(newValue)) {\n                error(`${isNaN(oldValue) ? 'NaN' : 'non-NaN value'}`, `${isNaN(newValue) ? 'NaN' : 'non-NaN value'}`, path, depth);\n            }\n        }\n        else if (oldValue !== newValue) {\n            error(oldValue, newValue, path, depth);\n        }\n    }\n    recur(oldValue, newValue, '', 0);\n}\n\nexports.$dispatcherGuard = $dispatcherGuard;\nexports.$makeReadOnly = $makeReadOnly;\nexports.$reset = $reset;\nexports.$structuralCheck = $structuralCheck;\nexports.c = c;\nexports.clearRenderCounterRegistry = clearRenderCounterRegistry;\nexports.renderCounterRegistry = renderCounterRegistry;\nexports.useRenderCounter = useRenderCounter;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtY29tcGlsZXItcnVudGltZUAwLjAuMC1leHBlcmltZW50YWwtMjJjNmU0OS0yMDI0MTIxOV9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LWNvbXBpbGVyLXJ1bnRpbWUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZCxZQUFZLG1CQUFPLENBQUMsNEtBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUSxvQ0FBb0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsS0FBSztBQUNwRTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTyxHQUFHLEtBQUssR0FBRyxLQUFLLElBQUksYUFBYSxFQUFFLE1BQU0sZUFBZSxHQUFHLEtBQUssR0FBRyxXQUFXLE1BQU07QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQixXQUFXLGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RDtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYyw2QkFBNkIsY0FBYztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxFQUFFLCtCQUErQixFQUFFO0FBQzlGO0FBQ0E7QUFDQSx5REFBeUQsS0FBSyxPQUFPLEVBQUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWMsNkJBQTZCLGNBQWM7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsRUFBRSxnQ0FBZ0MsRUFBRTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCLFdBQVcsOEJBQThCO0FBQ3pHO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCLHdCQUF3QixnQkFBZ0I7QUFDdkc7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0QsNkRBQTZELEtBQUssR0FBRyxHQUFHO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQXNELFdBQVcsc0RBQXNEO0FBQ3pKO0FBQ0E7QUFDQSxtREFBbUQsY0FBYyw0QkFBNEIsY0FBYztBQUMzRztBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJLHNCQUFzQixJQUFJO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELElBQUkseUJBQXlCLElBQUk7QUFDbEY7QUFDQTtBQUNBLCtEQUErRCxLQUFLLEdBQUcsSUFBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMENBQTBDLE1BQU0sMENBQTBDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQixjQUFjO0FBQ2Qsd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVCxrQ0FBa0M7QUFDbEMsNkJBQTZCO0FBQzdCLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsiL1VzZXJzL21vanRhYmEvRG9jdW1lbnRzL0dpdEh1Yi9kby9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtY29tcGlsZXItcnVudGltZUAwLjAuMC1leHBlcmltZW50YWwtMjJjNmU0OS0yMDI0MTIxOV9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LWNvbXBpbGVyLXJ1bnRpbWUvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpZ2h0U3ludGF4VHJhbnNmb3JtXG4gKiBAbm9mbG93XG4gKiBAbm9saW50XG4gKiBAcHJldmVudE11bmdlXG4gKiBAcHJlc2VydmUtaW52YXJpYW50LW1lc3NhZ2VzXG4gKi9cblxuXCJ1c2Ugbm8gbWVtb1wiOyd1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGUpIHtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG4uZGVmYXVsdCA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChSZWFjdCk7XG5cbnZhciBfYSwgX2I7XG5jb25zdCB7IHVzZVJlZiwgdXNlRWZmZWN0LCBpc1ZhbGlkRWxlbWVudCB9ID0gUmVhY3RfX25hbWVzcGFjZTtcbmNvbnN0IFJlYWN0U2VjcmV0SW50ZXJuYWxzID0gKF9hID0gUmVhY3RfX25hbWVzcGFjZS5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFJlYWN0X19uYW1lc3BhY2UuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5jb25zdCAkZW1wdHkgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsJyk7XG5jb25zdCBjID0gdHlwZW9mICgoX2IgPSBSZWFjdF9fbmFtZXNwYWNlLl9fQ09NUElMRVJfUlVOVElNRSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmMpID09PSAnZnVuY3Rpb24nXG4gICAgP1xuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLl9fQ09NUElMRVJfUlVOVElNRS5jXG4gICAgOiBmdW5jdGlvbiBjKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCAkID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHNpemU7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAkW2lpXSA9ICRlbXB0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRbJGVtcHR5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gJDtcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG5jb25zdCBMYXp5R3VhcmREaXNwYXRjaGVyID0ge307XG5bXG4gICAgJ3JlYWRDb250ZXh0JyxcbiAgICAndXNlQ2FsbGJhY2snLFxuICAgICd1c2VDb250ZXh0JyxcbiAgICAndXNlRWZmZWN0JyxcbiAgICAndXNlSW1wZXJhdGl2ZUhhbmRsZScsXG4gICAgJ3VzZUluc2VydGlvbkVmZmVjdCcsXG4gICAgJ3VzZUxheW91dEVmZmVjdCcsXG4gICAgJ3VzZU1lbW8nLFxuICAgICd1c2VSZWR1Y2VyJyxcbiAgICAndXNlUmVmJyxcbiAgICAndXNlU3RhdGUnLFxuICAgICd1c2VEZWJ1Z1ZhbHVlJyxcbiAgICAndXNlRGVmZXJyZWRWYWx1ZScsXG4gICAgJ3VzZVRyYW5zaXRpb24nLFxuICAgICd1c2VNdXRhYmxlU291cmNlJyxcbiAgICAndXNlU3luY0V4dGVybmFsU3RvcmUnLFxuICAgICd1c2VJZCcsXG4gICAgJ3Vuc3RhYmxlX2lzTmV3UmVjb25jaWxlcicsXG4gICAgJ2dldENhY2hlU2lnbmFsJyxcbiAgICAnZ2V0Q2FjaGVGb3JUeXBlJyxcbiAgICAndXNlQ2FjaGVSZWZyZXNoJyxcbl0uZm9yRWFjaChuYW1lID0+IHtcbiAgICBMYXp5R3VhcmREaXNwYXRjaGVyW25hbWVdID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtSZWFjdF0gVW5leHBlY3RlZCBSZWFjdCBob29rIGNhbGwgKCR7bmFtZX0pIGZyb20gYSBSZWFjdCBjb21waWxlZCBmdW5jdGlvbi4gYCArXG4gICAgICAgICAgICBcIkNoZWNrIHRoYXQgYWxsIGhvb2tzIGFyZSBjYWxsZWQgZGlyZWN0bHkgYW5kIG5hbWVkIGFjY29yZGluZyB0byBjb252ZW50aW9uICgndXNlW0EtWl0nKSBcIik7XG4gICAgfTtcbn0pO1xubGV0IG9yaWdpbmFsRGlzcGF0Y2hlciA9IG51bGw7XG5MYXp5R3VhcmREaXNwYXRjaGVyWyd1c2VNZW1vQ2FjaGUnXSA9IChjb3VudCkgPT4ge1xuICAgIGlmIChvcmlnaW5hbERpc3BhdGNoZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IENvbXBpbGVyIGludGVybmFsIGludmFyaWFudCB2aW9sYXRpb246IHVuZXhwZWN0ZWQgbnVsbCBkaXNwYXRjaGVyJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxEaXNwYXRjaGVyLnVzZU1lbW9DYWNoZShjb3VudCk7XG4gICAgfVxufTtcbnZhciBHdWFyZEtpbmQ7XG4oZnVuY3Rpb24gKEd1YXJkS2luZCkge1xuICAgIEd1YXJkS2luZFtHdWFyZEtpbmRbXCJQdXNoR3VhcmRDb250ZXh0XCJdID0gMF0gPSBcIlB1c2hHdWFyZENvbnRleHRcIjtcbiAgICBHdWFyZEtpbmRbR3VhcmRLaW5kW1wiUG9wR3VhcmRDb250ZXh0XCJdID0gMV0gPSBcIlBvcEd1YXJkQ29udGV4dFwiO1xuICAgIEd1YXJkS2luZFtHdWFyZEtpbmRbXCJQdXNoRXhwZWN0SG9va1wiXSA9IDJdID0gXCJQdXNoRXhwZWN0SG9va1wiO1xuICAgIEd1YXJkS2luZFtHdWFyZEtpbmRbXCJQb3BFeHBlY3RIb29rXCJdID0gM10gPSBcIlBvcEV4cGVjdEhvb2tcIjtcbn0pKEd1YXJkS2luZCB8fCAoR3VhcmRLaW5kID0ge30pKTtcbmZ1bmN0aW9uIHNldEN1cnJlbnQobmV3RGlzcGF0Y2hlcikge1xuICAgIFJlYWN0U2VjcmV0SW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG5ld0Rpc3BhdGNoZXI7XG4gICAgcmV0dXJuIFJlYWN0U2VjcmV0SW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbn1cbmNvbnN0IGd1YXJkRnJhbWVzID0gW107XG5mdW5jdGlvbiAkZGlzcGF0Y2hlckd1YXJkKGtpbmQpIHtcbiAgICBjb25zdCBjdXJyID0gUmVhY3RTZWNyZXRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICAgIGlmIChraW5kID09PSBHdWFyZEtpbmQuUHVzaEd1YXJkQ29udGV4dCkge1xuICAgICAgICBndWFyZEZyYW1lcy5wdXNoKGN1cnIpO1xuICAgICAgICBpZiAoZ3VhcmRGcmFtZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBvcmlnaW5hbERpc3BhdGNoZXIgPSBjdXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyID09PSBMYXp5R3VhcmREaXNwYXRjaGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtSZWFjdF0gVW5leHBlY3RlZCBjYWxsIHRvIGN1c3RvbSBob29rIG9yIGNvbXBvbmVudCBmcm9tIGEgUmVhY3QgY29tcGlsZWQgZnVuY3Rpb24uIGAgK1xuICAgICAgICAgICAgICAgIFwiQ2hlY2sgdGhhdCAoMSkgYWxsIGhvb2tzIGFyZSBjYWxsZWQgZGlyZWN0bHkgYW5kIG5hbWVkIGFjY29yZGluZyB0byBjb252ZW50aW9uICgndXNlW0EtWl0nKSBcIiArXG4gICAgICAgICAgICAgICAgJ2FuZCAoMikgY29tcG9uZW50cyBhcmUgcmV0dXJuZWQgYXMgSlNYIGluc3RlYWQgb2YgYmVpbmcgZGlyZWN0bHkgaW52b2tlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDdXJyZW50KExhenlHdWFyZERpc3BhdGNoZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChraW5kID09PSBHdWFyZEtpbmQuUG9wR3VhcmRDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGxhc3RGcmFtZSA9IGd1YXJkRnJhbWVzLnBvcCgpO1xuICAgICAgICBpZiAobGFzdEZyYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QgQ29tcGlsZXIgaW50ZXJuYWwgZXJyb3I6IHVuZXhwZWN0ZWQgbnVsbCBpbiBndWFyZCBzdGFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChndWFyZEZyYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRGlzcGF0Y2hlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q3VycmVudChsYXN0RnJhbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChraW5kID09PSBHdWFyZEtpbmQuUHVzaEV4cGVjdEhvb2spIHtcbiAgICAgICAgZ3VhcmRGcmFtZXMucHVzaChjdXJyKTtcbiAgICAgICAgc2V0Q3VycmVudChvcmlnaW5hbERpc3BhdGNoZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChraW5kID09PSBHdWFyZEtpbmQuUG9wRXhwZWN0SG9vaykge1xuICAgICAgICBjb25zdCBsYXN0RnJhbWUgPSBndWFyZEZyYW1lcy5wb3AoKTtcbiAgICAgICAgaWYgKGxhc3RGcmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IENvbXBpbGVyIGludGVybmFsIGVycm9yOiB1bmV4cGVjdGVkIG51bGwgaW4gZ3VhcmQgc3RhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDdXJyZW50KGxhc3RGcmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IENvbXBpbGVyIGludGVybmFsIGVycm9yOiB1bnJlYWNoYWJsZSBibG9jaycgKyBraW5kKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkcmVzZXQoJCkge1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCAkLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAkW2lpXSA9ICRlbXB0eTtcbiAgICB9XG59XG5mdW5jdGlvbiAkbWFrZVJlYWRPbmx5KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVE9ETzogaW1wbGVtZW50ICRtYWtlUmVhZE9ubHkgaW4gcmVhY3QtY29tcGlsZXItcnVudGltZScpO1xufVxuY29uc3QgcmVuZGVyQ291bnRlclJlZ2lzdHJ5ID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY2xlYXJSZW5kZXJDb3VudGVyUmVnaXN0cnkoKSB7XG4gICAgZm9yIChjb25zdCBjb3VudGVycyBvZiByZW5kZXJDb3VudGVyUmVnaXN0cnkudmFsdWVzKCkpIHtcbiAgICAgICAgY291bnRlcnMuZm9yRWFjaChjb3VudGVyID0+IHtcbiAgICAgICAgICAgIGNvdW50ZXIuY291bnQgPSAwO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWdpc3RlclJlbmRlckNvdW50ZXIobmFtZSwgdmFsKSB7XG4gICAgbGV0IGNvdW50ZXJzID0gcmVuZGVyQ291bnRlclJlZ2lzdHJ5LmdldChuYW1lKTtcbiAgICBpZiAoY291bnRlcnMgPT0gbnVsbCkge1xuICAgICAgICBjb3VudGVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcmVuZGVyQ291bnRlclJlZ2lzdHJ5LnNldChuYW1lLCBjb3VudGVycyk7XG4gICAgfVxuICAgIGNvdW50ZXJzLmFkZCh2YWwpO1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVuZGVyQ291bnRlcihuYW1lLCB2YWwpIHtcbiAgICBjb25zdCBjb3VudGVycyA9IHJlbmRlckNvdW50ZXJSZWdpc3RyeS5nZXQobmFtZSk7XG4gICAgaWYgKGNvdW50ZXJzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb3VudGVycy5kZWxldGUodmFsKTtcbn1cbmZ1bmN0aW9uIHVzZVJlbmRlckNvdW50ZXIobmFtZSkge1xuICAgIGNvbnN0IHZhbCA9IHVzZVJlZihudWxsKTtcbiAgICBpZiAodmFsLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICB2YWwuY3VycmVudC5jb3VudCArPSAxO1xuICAgIH1cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodmFsLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY291bnRlciA9IHsgY291bnQ6IDAgfTtcbiAgICAgICAgICAgIHJlZ2lzdGVyUmVuZGVyQ291bnRlcihuYW1lLCBjb3VudGVyKTtcbiAgICAgICAgICAgIHZhbC5jdXJyZW50ID0gY291bnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbC5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlUmVuZGVyQ291bnRlcihuYW1lLCB2YWwuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5jb25zdCBzZWVuRXJyb3JzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gJHN0cnVjdHVyYWxDaGVjayhvbGRWYWx1ZSwgbmV3VmFsdWUsIHZhcmlhYmxlTmFtZSwgZm5OYW1lLCBraW5kLCBsb2MpIHtcbiAgICBmdW5jdGlvbiBlcnJvcihsLCByLCBwYXRoLCBkZXB0aCkge1xuICAgICAgICBjb25zdCBzdHIgPSBgJHtmbk5hbWV9OiR7bG9jfSBbJHtraW5kfV0gJHt2YXJpYWJsZU5hbWV9JHtwYXRofSBjaGFuZ2VkIGZyb20gJHtsfSB0byAke3J9IGF0IGRlcHRoICR7ZGVwdGh9YDtcbiAgICAgICAgaWYgKHNlZW5FcnJvcnMuaGFzKHN0cikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWVuRXJyb3JzLmFkZChzdHIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKHN0cik7XG4gICAgfVxuICAgIGNvbnN0IGRlcHRoTGltaXQgPSAyO1xuICAgIGZ1bmN0aW9uIHJlY3VyKG9sZFZhbHVlLCBuZXdWYWx1ZSwgcGF0aCwgZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID4gZGVwdGhMaW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZFZhbHVlID09PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvbGRWYWx1ZSAhPT0gdHlwZW9mIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBlcnJvcihgdHlwZSAke3R5cGVvZiBvbGRWYWx1ZX1gLCBgdHlwZSAke3R5cGVvZiBuZXdWYWx1ZX1gLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9sZFZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgb2xkQXJyYXkgPSBBcnJheS5pc0FycmF5KG9sZFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gQXJyYXkuaXNBcnJheShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgPT09IG51bGwgJiYgbmV3VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignbnVsbCcsIGB0eXBlICR7dHlwZW9mIG5ld1ZhbHVlfWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoYHR5cGUgJHt0eXBlb2Ygb2xkVmFsdWV9YCwgJ251bGwnLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIGlmICghKG5ld1ZhbHVlIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgTWFwIGluc3RhbmNlYCwgYG90aGVyIHZhbHVlYCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZS5zaXplICE9PSBuZXdWYWx1ZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGBNYXAgaW5zdGFuY2Ugd2l0aCBzaXplICR7b2xkVmFsdWUuc2l6ZX1gLCBgTWFwIGluc3RhbmNlIHdpdGggc2l6ZSAke25ld1ZhbHVlLnNpemV9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2Ygb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV3VmFsdWUuaGFzKGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoYE1hcCBpbnN0YW5jZSB3aXRoIGtleSAke2t9YCwgYE1hcCBpbnN0YW5jZSB3aXRob3V0IGtleSAke2t9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXIodiwgbmV3VmFsdWUuZ2V0KGspLCBgJHtwYXRofS5nZXQoJHtrfSlgLCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBlcnJvcignb3RoZXIgdmFsdWUnLCBgTWFwIGluc3RhbmNlYCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShuZXdWYWx1ZSBpbnN0YW5jZW9mIFNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoYFNldCBpbnN0YW5jZWAsIGBvdGhlciB2YWx1ZWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUuc2l6ZSAhPT0gbmV3VmFsdWUuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgU2V0IGluc3RhbmNlIHdpdGggc2l6ZSAke29sZFZhbHVlLnNpemV9YCwgYFNldCBpbnN0YW5jZSB3aXRoIHNpemUgJHtuZXdWYWx1ZS5zaXplfWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZS5oYXModikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihgU2V0IGluc3RhbmNlIHdpdGhvdXQgZWxlbWVudCAke3Z9YCwgYFNldCBpbnN0YW5jZSB3aXRoIGVsZW1lbnQgJHt2fWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ290aGVyIHZhbHVlJywgYFNldCBpbnN0YW5jZWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9sZEFycmF5IHx8IG5ld0FycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEFycmF5ICE9PSBuZXdBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgdHlwZSAke29sZEFycmF5ID8gJ2FycmF5JyA6ICdvYmplY3QnfWAsIGB0eXBlICR7bmV3QXJyYXkgPyAnYXJyYXknIDogJ29iamVjdCd9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZS5sZW5ndGggIT09IG5ld1ZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgYXJyYXkgd2l0aCBsZW5ndGggJHtvbGRWYWx1ZS5sZW5ndGh9YCwgYGFycmF5IHdpdGggbGVuZ3RoICR7bmV3VmFsdWUubGVuZ3RofWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBvbGRWYWx1ZS5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3VyKG9sZFZhbHVlW2lpXSwgbmV3VmFsdWVbaWldLCBgJHtwYXRofVske2lpfV1gLCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQob2xkVmFsdWUpIHx8IGlzVmFsaWRFbGVtZW50KG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChvbGRWYWx1ZSkgIT09IGlzVmFsaWRFbGVtZW50KG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgdHlwZSAke2lzVmFsaWRFbGVtZW50KG9sZFZhbHVlKSA/ICdSZWFjdCBlbGVtZW50JyA6ICdvYmplY3QnfWAsIGB0eXBlICR7aXNWYWxpZEVsZW1lbnQobmV3VmFsdWUpID8gJ1JlYWN0IGVsZW1lbnQnIDogJ29iamVjdCd9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZS50eXBlICE9PSBuZXdWYWx1ZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGBSZWFjdCBlbGVtZW50IG9mIHR5cGUgJHtvbGRWYWx1ZS50eXBlfWAsIGBSZWFjdCBlbGVtZW50IG9mIHR5cGUgJHtuZXdWYWx1ZS50eXBlfWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3VyKG9sZFZhbHVlLnByb3BzLCBuZXdWYWx1ZS5wcm9wcywgYFtwcm9wcyBvZiAke3BhdGh9XWAsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoYG9iamVjdCB3aXRob3V0IGtleSAke2tleX1gLCBgb2JqZWN0IHdpdGgga2V5ICR7a2V5fWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihgb2JqZWN0IHdpdGgga2V5ICR7a2V5fWAsIGBvYmplY3Qgd2l0aG91dCBrZXkgJHtrZXl9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXIob2xkVmFsdWVba2V5XSwgbmV3VmFsdWVba2V5XSwgYCR7cGF0aH0uJHtrZXl9YCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2xkVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc05hTihvbGRWYWx1ZSkgfHwgaXNOYU4obmV3VmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4ob2xkVmFsdWUpICE9PSBpc05hTihuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihgJHtpc05hTihvbGRWYWx1ZSkgPyAnTmFOJyA6ICdub24tTmFOIHZhbHVlJ31gLCBgJHtpc05hTihuZXdWYWx1ZSkgPyAnTmFOJyA6ICdub24tTmFOIHZhbHVlJ31gLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBlcnJvcihvbGRWYWx1ZSwgbmV3VmFsdWUsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWN1cihvbGRWYWx1ZSwgbmV3VmFsdWUsICcnLCAwKTtcbn1cblxuZXhwb3J0cy4kZGlzcGF0Y2hlckd1YXJkID0gJGRpc3BhdGNoZXJHdWFyZDtcbmV4cG9ydHMuJG1ha2VSZWFkT25seSA9ICRtYWtlUmVhZE9ubHk7XG5leHBvcnRzLiRyZXNldCA9ICRyZXNldDtcbmV4cG9ydHMuJHN0cnVjdHVyYWxDaGVjayA9ICRzdHJ1Y3R1cmFsQ2hlY2s7XG5leHBvcnRzLmMgPSBjO1xuZXhwb3J0cy5jbGVhclJlbmRlckNvdW50ZXJSZWdpc3RyeSA9IGNsZWFyUmVuZGVyQ291bnRlclJlZ2lzdHJ5O1xuZXhwb3J0cy5yZW5kZXJDb3VudGVyUmVnaXN0cnkgPSByZW5kZXJDb3VudGVyUmVnaXN0cnk7XG5leHBvcnRzLnVzZVJlbmRlckNvdW50ZXIgPSB1c2VSZW5kZXJDb3VudGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/react-compiler-runtime@0.0.0-experimental-22c6e49-20241219_react@19.0.0/node_modules/react-compiler-runtime/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-compiler-runtime@0.0.0-experimental-22c6e49-20241219_react@19.0.0/node_modules/react-compiler-runtime/dist/index.js":
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-compiler-runtime@0.0.0-experimental-22c6e49-20241219_react@19.0.0/node_modules/react-compiler-runtime/dist/index.js ***!
  \******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @lightSyntaxTransform\n * @noflow\n * @nolint\n * @preventMunge\n * @preserve-invariant-messages\n */\n\n\"use no memo\";'use strict';\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.2.3_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () { return e[k]; }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);\n\nvar _a, _b;\nconst { useRef, useEffect, isValidElement } = React__namespace;\nconst ReactSecretInternals = (_a = React__namespace.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) !== null && _a !== void 0 ? _a : React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nconst $empty = Symbol.for('react.memo_cache_sentinel');\nconst c = typeof ((_b = React__namespace.__COMPILER_RUNTIME) === null || _b === void 0 ? void 0 : _b.c) === 'function'\n    ?\n        React__namespace.__COMPILER_RUNTIME.c\n    : function c(size) {\n        return React__namespace.useMemo(() => {\n            const $ = new Array(size);\n            for (let ii = 0; ii < size; ii++) {\n                $[ii] = $empty;\n            }\n            $[$empty] = true;\n            return $;\n        }, []);\n    };\nconst LazyGuardDispatcher = {};\n[\n    'readContext',\n    'useCallback',\n    'useContext',\n    'useEffect',\n    'useImperativeHandle',\n    'useInsertionEffect',\n    'useLayoutEffect',\n    'useMemo',\n    'useReducer',\n    'useRef',\n    'useState',\n    'useDebugValue',\n    'useDeferredValue',\n    'useTransition',\n    'useMutableSource',\n    'useSyncExternalStore',\n    'useId',\n    'unstable_isNewReconciler',\n    'getCacheSignal',\n    'getCacheForType',\n    'useCacheRefresh',\n].forEach(name => {\n    LazyGuardDispatcher[name] = () => {\n        throw new Error(`[React] Unexpected React hook call (${name}) from a React compiled function. ` +\n            \"Check that all hooks are called directly and named according to convention ('use[A-Z]') \");\n    };\n});\nlet originalDispatcher = null;\nLazyGuardDispatcher['useMemoCache'] = (count) => {\n    if (originalDispatcher == null) {\n        throw new Error('React Compiler internal invariant violation: unexpected null dispatcher');\n    }\n    else {\n        return originalDispatcher.useMemoCache(count);\n    }\n};\nvar GuardKind;\n(function (GuardKind) {\n    GuardKind[GuardKind[\"PushGuardContext\"] = 0] = \"PushGuardContext\";\n    GuardKind[GuardKind[\"PopGuardContext\"] = 1] = \"PopGuardContext\";\n    GuardKind[GuardKind[\"PushExpectHook\"] = 2] = \"PushExpectHook\";\n    GuardKind[GuardKind[\"PopExpectHook\"] = 3] = \"PopExpectHook\";\n})(GuardKind || (GuardKind = {}));\nfunction setCurrent(newDispatcher) {\n    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;\n    return ReactSecretInternals.ReactCurrentDispatcher.current;\n}\nconst guardFrames = [];\nfunction $dispatcherGuard(kind) {\n    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;\n    if (kind === GuardKind.PushGuardContext) {\n        guardFrames.push(curr);\n        if (guardFrames.length === 1) {\n            originalDispatcher = curr;\n        }\n        if (curr === LazyGuardDispatcher) {\n            throw new Error(`[React] Unexpected call to custom hook or component from a React compiled function. ` +\n                \"Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') \" +\n                'and (2) components are returned as JSX instead of being directly invoked.');\n        }\n        setCurrent(LazyGuardDispatcher);\n    }\n    else if (kind === GuardKind.PopGuardContext) {\n        const lastFrame = guardFrames.pop();\n        if (lastFrame == null) {\n            throw new Error('React Compiler internal error: unexpected null in guard stack');\n        }\n        if (guardFrames.length === 0) {\n            originalDispatcher = null;\n        }\n        setCurrent(lastFrame);\n    }\n    else if (kind === GuardKind.PushExpectHook) {\n        guardFrames.push(curr);\n        setCurrent(originalDispatcher);\n    }\n    else if (kind === GuardKind.PopExpectHook) {\n        const lastFrame = guardFrames.pop();\n        if (lastFrame == null) {\n            throw new Error('React Compiler internal error: unexpected null in guard stack');\n        }\n        setCurrent(lastFrame);\n    }\n    else {\n        throw new Error('React Compiler internal error: unreachable block' + kind);\n    }\n}\nfunction $reset($) {\n    for (let ii = 0; ii < $.length; ii++) {\n        $[ii] = $empty;\n    }\n}\nfunction $makeReadOnly() {\n    throw new Error('TODO: implement $makeReadOnly in react-compiler-runtime');\n}\nconst renderCounterRegistry = new Map();\nfunction clearRenderCounterRegistry() {\n    for (const counters of renderCounterRegistry.values()) {\n        counters.forEach(counter => {\n            counter.count = 0;\n        });\n    }\n}\nfunction registerRenderCounter(name, val) {\n    let counters = renderCounterRegistry.get(name);\n    if (counters == null) {\n        counters = new Set();\n        renderCounterRegistry.set(name, counters);\n    }\n    counters.add(val);\n}\nfunction removeRenderCounter(name, val) {\n    const counters = renderCounterRegistry.get(name);\n    if (counters == null) {\n        return;\n    }\n    counters.delete(val);\n}\nfunction useRenderCounter(name) {\n    const val = useRef(null);\n    if (val.current != null) {\n        val.current.count += 1;\n    }\n    useEffect(() => {\n        if (val.current == null) {\n            const counter = { count: 0 };\n            registerRenderCounter(name, counter);\n            val.current = counter;\n        }\n        return () => {\n            if (val.current !== null) {\n                removeRenderCounter(name, val.current);\n            }\n        };\n    });\n}\nconst seenErrors = new Set();\nfunction $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {\n    function error(l, r, path, depth) {\n        const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;\n        if (seenErrors.has(str)) {\n            return;\n        }\n        seenErrors.add(str);\n        console.error(str);\n    }\n    const depthLimit = 2;\n    function recur(oldValue, newValue, path, depth) {\n        if (depth > depthLimit) {\n            return;\n        }\n        else if (oldValue === newValue) {\n            return;\n        }\n        else if (typeof oldValue !== typeof newValue) {\n            error(`type ${typeof oldValue}`, `type ${typeof newValue}`, path, depth);\n        }\n        else if (typeof oldValue === 'object') {\n            const oldArray = Array.isArray(oldValue);\n            const newArray = Array.isArray(newValue);\n            if (oldValue === null && newValue !== null) {\n                error('null', `type ${typeof newValue}`, path, depth);\n            }\n            else if (newValue === null) {\n                error(`type ${typeof oldValue}`, 'null', path, depth);\n            }\n            else if (oldValue instanceof Map) {\n                if (!(newValue instanceof Map)) {\n                    error(`Map instance`, `other value`, path, depth);\n                }\n                else if (oldValue.size !== newValue.size) {\n                    error(`Map instance with size ${oldValue.size}`, `Map instance with size ${newValue.size}`, path, depth);\n                }\n                else {\n                    for (const [k, v] of oldValue) {\n                        if (!newValue.has(k)) {\n                            error(`Map instance with key ${k}`, `Map instance without key ${k}`, path, depth);\n                        }\n                        else {\n                            recur(v, newValue.get(k), `${path}.get(${k})`, depth + 1);\n                        }\n                    }\n                }\n            }\n            else if (newValue instanceof Map) {\n                error('other value', `Map instance`, path, depth);\n            }\n            else if (oldValue instanceof Set) {\n                if (!(newValue instanceof Set)) {\n                    error(`Set instance`, `other value`, path, depth);\n                }\n                else if (oldValue.size !== newValue.size) {\n                    error(`Set instance with size ${oldValue.size}`, `Set instance with size ${newValue.size}`, path, depth);\n                }\n                else {\n                    for (const v of newValue) {\n                        if (!oldValue.has(v)) {\n                            error(`Set instance without element ${v}`, `Set instance with element ${v}`, path, depth);\n                        }\n                    }\n                }\n            }\n            else if (newValue instanceof Set) {\n                error('other value', `Set instance`, path, depth);\n            }\n            else if (oldArray || newArray) {\n                if (oldArray !== newArray) {\n                    error(`type ${oldArray ? 'array' : 'object'}`, `type ${newArray ? 'array' : 'object'}`, path, depth);\n                }\n                else if (oldValue.length !== newValue.length) {\n                    error(`array with length ${oldValue.length}`, `array with length ${newValue.length}`, path, depth);\n                }\n                else {\n                    for (let ii = 0; ii < oldValue.length; ii++) {\n                        recur(oldValue[ii], newValue[ii], `${path}[${ii}]`, depth + 1);\n                    }\n                }\n            }\n            else if (isValidElement(oldValue) || isValidElement(newValue)) {\n                if (isValidElement(oldValue) !== isValidElement(newValue)) {\n                    error(`type ${isValidElement(oldValue) ? 'React element' : 'object'}`, `type ${isValidElement(newValue) ? 'React element' : 'object'}`, path, depth);\n                }\n                else if (oldValue.type !== newValue.type) {\n                    error(`React element of type ${oldValue.type}`, `React element of type ${newValue.type}`, path, depth);\n                }\n                else {\n                    recur(oldValue.props, newValue.props, `[props of ${path}]`, depth + 1);\n                }\n            }\n            else {\n                for (const key in newValue) {\n                    if (!(key in oldValue)) {\n                        error(`object without key ${key}`, `object with key ${key}`, path, depth);\n                    }\n                }\n                for (const key in oldValue) {\n                    if (!(key in newValue)) {\n                        error(`object with key ${key}`, `object without key ${key}`, path, depth);\n                    }\n                    else {\n                        recur(oldValue[key], newValue[key], `${path}.${key}`, depth + 1);\n                    }\n                }\n            }\n        }\n        else if (typeof oldValue === 'function') {\n            return;\n        }\n        else if (isNaN(oldValue) || isNaN(newValue)) {\n            if (isNaN(oldValue) !== isNaN(newValue)) {\n                error(`${isNaN(oldValue) ? 'NaN' : 'non-NaN value'}`, `${isNaN(newValue) ? 'NaN' : 'non-NaN value'}`, path, depth);\n            }\n        }\n        else if (oldValue !== newValue) {\n            error(oldValue, newValue, path, depth);\n        }\n    }\n    recur(oldValue, newValue, '', 0);\n}\n\nexports.$dispatcherGuard = $dispatcherGuard;\nexports.$makeReadOnly = $makeReadOnly;\nexports.$reset = $reset;\nexports.$structuralCheck = $structuralCheck;\nexports.c = c;\nexports.clearRenderCounterRegistry = clearRenderCounterRegistry;\nexports.renderCounterRegistry = renderCounterRegistry;\nexports.useRenderCounter = useRenderCounter;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtY29tcGlsZXItcnVudGltZUAwLjAuMC1leHBlcmltZW50YWwtMjJjNmU0OS0yMDI0MTIxOV9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LWNvbXBpbGVyLXJ1bnRpbWUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZCxZQUFZLG1CQUFPLENBQUMsNEtBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUSxvQ0FBb0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsS0FBSztBQUNwRTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTyxHQUFHLEtBQUssR0FBRyxLQUFLLElBQUksYUFBYSxFQUFFLE1BQU0sZUFBZSxHQUFHLEtBQUssR0FBRyxXQUFXLE1BQU07QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQixXQUFXLGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RDtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYyw2QkFBNkIsY0FBYztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxFQUFFLCtCQUErQixFQUFFO0FBQzlGO0FBQ0E7QUFDQSx5REFBeUQsS0FBSyxPQUFPLEVBQUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWMsNkJBQTZCLGNBQWM7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsRUFBRSxnQ0FBZ0MsRUFBRTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCLFdBQVcsOEJBQThCO0FBQ3pHO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCLHdCQUF3QixnQkFBZ0I7QUFDdkc7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0QsNkRBQTZELEtBQUssR0FBRyxHQUFHO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQXNELFdBQVcsc0RBQXNEO0FBQ3pKO0FBQ0E7QUFDQSxtREFBbUQsY0FBYyw0QkFBNEIsY0FBYztBQUMzRztBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJLHNCQUFzQixJQUFJO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELElBQUkseUJBQXlCLElBQUk7QUFDbEY7QUFDQTtBQUNBLCtEQUErRCxLQUFLLEdBQUcsSUFBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMENBQTBDLE1BQU0sMENBQTBDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQixjQUFjO0FBQ2Qsd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVCxrQ0FBa0M7QUFDbEMsNkJBQTZCO0FBQzdCLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsiL1VzZXJzL21vanRhYmEvRG9jdW1lbnRzL0dpdEh1Yi9kby9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtY29tcGlsZXItcnVudGltZUAwLjAuMC1leHBlcmltZW50YWwtMjJjNmU0OS0yMDI0MTIxOV9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LWNvbXBpbGVyLXJ1bnRpbWUvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpZ2h0U3ludGF4VHJhbnNmb3JtXG4gKiBAbm9mbG93XG4gKiBAbm9saW50XG4gKiBAcHJldmVudE11bmdlXG4gKiBAcHJlc2VydmUtaW52YXJpYW50LW1lc3NhZ2VzXG4gKi9cblxuXCJ1c2Ugbm8gbWVtb1wiOyd1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGUpIHtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG4uZGVmYXVsdCA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChSZWFjdCk7XG5cbnZhciBfYSwgX2I7XG5jb25zdCB7IHVzZVJlZiwgdXNlRWZmZWN0LCBpc1ZhbGlkRWxlbWVudCB9ID0gUmVhY3RfX25hbWVzcGFjZTtcbmNvbnN0IFJlYWN0U2VjcmV0SW50ZXJuYWxzID0gKF9hID0gUmVhY3RfX25hbWVzcGFjZS5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFJlYWN0X19uYW1lc3BhY2UuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5jb25zdCAkZW1wdHkgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsJyk7XG5jb25zdCBjID0gdHlwZW9mICgoX2IgPSBSZWFjdF9fbmFtZXNwYWNlLl9fQ09NUElMRVJfUlVOVElNRSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmMpID09PSAnZnVuY3Rpb24nXG4gICAgP1xuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLl9fQ09NUElMRVJfUlVOVElNRS5jXG4gICAgOiBmdW5jdGlvbiBjKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCAkID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHNpemU7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAkW2lpXSA9ICRlbXB0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRbJGVtcHR5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gJDtcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG5jb25zdCBMYXp5R3VhcmREaXNwYXRjaGVyID0ge307XG5bXG4gICAgJ3JlYWRDb250ZXh0JyxcbiAgICAndXNlQ2FsbGJhY2snLFxuICAgICd1c2VDb250ZXh0JyxcbiAgICAndXNlRWZmZWN0JyxcbiAgICAndXNlSW1wZXJhdGl2ZUhhbmRsZScsXG4gICAgJ3VzZUluc2VydGlvbkVmZmVjdCcsXG4gICAgJ3VzZUxheW91dEVmZmVjdCcsXG4gICAgJ3VzZU1lbW8nLFxuICAgICd1c2VSZWR1Y2VyJyxcbiAgICAndXNlUmVmJyxcbiAgICAndXNlU3RhdGUnLFxuICAgICd1c2VEZWJ1Z1ZhbHVlJyxcbiAgICAndXNlRGVmZXJyZWRWYWx1ZScsXG4gICAgJ3VzZVRyYW5zaXRpb24nLFxuICAgICd1c2VNdXRhYmxlU291cmNlJyxcbiAgICAndXNlU3luY0V4dGVybmFsU3RvcmUnLFxuICAgICd1c2VJZCcsXG4gICAgJ3Vuc3RhYmxlX2lzTmV3UmVjb25jaWxlcicsXG4gICAgJ2dldENhY2hlU2lnbmFsJyxcbiAgICAnZ2V0Q2FjaGVGb3JUeXBlJyxcbiAgICAndXNlQ2FjaGVSZWZyZXNoJyxcbl0uZm9yRWFjaChuYW1lID0+IHtcbiAgICBMYXp5R3VhcmREaXNwYXRjaGVyW25hbWVdID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtSZWFjdF0gVW5leHBlY3RlZCBSZWFjdCBob29rIGNhbGwgKCR7bmFtZX0pIGZyb20gYSBSZWFjdCBjb21waWxlZCBmdW5jdGlvbi4gYCArXG4gICAgICAgICAgICBcIkNoZWNrIHRoYXQgYWxsIGhvb2tzIGFyZSBjYWxsZWQgZGlyZWN0bHkgYW5kIG5hbWVkIGFjY29yZGluZyB0byBjb252ZW50aW9uICgndXNlW0EtWl0nKSBcIik7XG4gICAgfTtcbn0pO1xubGV0IG9yaWdpbmFsRGlzcGF0Y2hlciA9IG51bGw7XG5MYXp5R3VhcmREaXNwYXRjaGVyWyd1c2VNZW1vQ2FjaGUnXSA9IChjb3VudCkgPT4ge1xuICAgIGlmIChvcmlnaW5hbERpc3BhdGNoZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IENvbXBpbGVyIGludGVybmFsIGludmFyaWFudCB2aW9sYXRpb246IHVuZXhwZWN0ZWQgbnVsbCBkaXNwYXRjaGVyJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxEaXNwYXRjaGVyLnVzZU1lbW9DYWNoZShjb3VudCk7XG4gICAgfVxufTtcbnZhciBHdWFyZEtpbmQ7XG4oZnVuY3Rpb24gKEd1YXJkS2luZCkge1xuICAgIEd1YXJkS2luZFtHdWFyZEtpbmRbXCJQdXNoR3VhcmRDb250ZXh0XCJdID0gMF0gPSBcIlB1c2hHdWFyZENvbnRleHRcIjtcbiAgICBHdWFyZEtpbmRbR3VhcmRLaW5kW1wiUG9wR3VhcmRDb250ZXh0XCJdID0gMV0gPSBcIlBvcEd1YXJkQ29udGV4dFwiO1xuICAgIEd1YXJkS2luZFtHdWFyZEtpbmRbXCJQdXNoRXhwZWN0SG9va1wiXSA9IDJdID0gXCJQdXNoRXhwZWN0SG9va1wiO1xuICAgIEd1YXJkS2luZFtHdWFyZEtpbmRbXCJQb3BFeHBlY3RIb29rXCJdID0gM10gPSBcIlBvcEV4cGVjdEhvb2tcIjtcbn0pKEd1YXJkS2luZCB8fCAoR3VhcmRLaW5kID0ge30pKTtcbmZ1bmN0aW9uIHNldEN1cnJlbnQobmV3RGlzcGF0Y2hlcikge1xuICAgIFJlYWN0U2VjcmV0SW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG5ld0Rpc3BhdGNoZXI7XG4gICAgcmV0dXJuIFJlYWN0U2VjcmV0SW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbn1cbmNvbnN0IGd1YXJkRnJhbWVzID0gW107XG5mdW5jdGlvbiAkZGlzcGF0Y2hlckd1YXJkKGtpbmQpIHtcbiAgICBjb25zdCBjdXJyID0gUmVhY3RTZWNyZXRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICAgIGlmIChraW5kID09PSBHdWFyZEtpbmQuUHVzaEd1YXJkQ29udGV4dCkge1xuICAgICAgICBndWFyZEZyYW1lcy5wdXNoKGN1cnIpO1xuICAgICAgICBpZiAoZ3VhcmRGcmFtZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBvcmlnaW5hbERpc3BhdGNoZXIgPSBjdXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyID09PSBMYXp5R3VhcmREaXNwYXRjaGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtSZWFjdF0gVW5leHBlY3RlZCBjYWxsIHRvIGN1c3RvbSBob29rIG9yIGNvbXBvbmVudCBmcm9tIGEgUmVhY3QgY29tcGlsZWQgZnVuY3Rpb24uIGAgK1xuICAgICAgICAgICAgICAgIFwiQ2hlY2sgdGhhdCAoMSkgYWxsIGhvb2tzIGFyZSBjYWxsZWQgZGlyZWN0bHkgYW5kIG5hbWVkIGFjY29yZGluZyB0byBjb252ZW50aW9uICgndXNlW0EtWl0nKSBcIiArXG4gICAgICAgICAgICAgICAgJ2FuZCAoMikgY29tcG9uZW50cyBhcmUgcmV0dXJuZWQgYXMgSlNYIGluc3RlYWQgb2YgYmVpbmcgZGlyZWN0bHkgaW52b2tlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDdXJyZW50KExhenlHdWFyZERpc3BhdGNoZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChraW5kID09PSBHdWFyZEtpbmQuUG9wR3VhcmRDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGxhc3RGcmFtZSA9IGd1YXJkRnJhbWVzLnBvcCgpO1xuICAgICAgICBpZiAobGFzdEZyYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QgQ29tcGlsZXIgaW50ZXJuYWwgZXJyb3I6IHVuZXhwZWN0ZWQgbnVsbCBpbiBndWFyZCBzdGFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChndWFyZEZyYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRGlzcGF0Y2hlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q3VycmVudChsYXN0RnJhbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChraW5kID09PSBHdWFyZEtpbmQuUHVzaEV4cGVjdEhvb2spIHtcbiAgICAgICAgZ3VhcmRGcmFtZXMucHVzaChjdXJyKTtcbiAgICAgICAgc2V0Q3VycmVudChvcmlnaW5hbERpc3BhdGNoZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChraW5kID09PSBHdWFyZEtpbmQuUG9wRXhwZWN0SG9vaykge1xuICAgICAgICBjb25zdCBsYXN0RnJhbWUgPSBndWFyZEZyYW1lcy5wb3AoKTtcbiAgICAgICAgaWYgKGxhc3RGcmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IENvbXBpbGVyIGludGVybmFsIGVycm9yOiB1bmV4cGVjdGVkIG51bGwgaW4gZ3VhcmQgc3RhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDdXJyZW50KGxhc3RGcmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IENvbXBpbGVyIGludGVybmFsIGVycm9yOiB1bnJlYWNoYWJsZSBibG9jaycgKyBraW5kKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkcmVzZXQoJCkge1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCAkLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAkW2lpXSA9ICRlbXB0eTtcbiAgICB9XG59XG5mdW5jdGlvbiAkbWFrZVJlYWRPbmx5KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVE9ETzogaW1wbGVtZW50ICRtYWtlUmVhZE9ubHkgaW4gcmVhY3QtY29tcGlsZXItcnVudGltZScpO1xufVxuY29uc3QgcmVuZGVyQ291bnRlclJlZ2lzdHJ5ID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY2xlYXJSZW5kZXJDb3VudGVyUmVnaXN0cnkoKSB7XG4gICAgZm9yIChjb25zdCBjb3VudGVycyBvZiByZW5kZXJDb3VudGVyUmVnaXN0cnkudmFsdWVzKCkpIHtcbiAgICAgICAgY291bnRlcnMuZm9yRWFjaChjb3VudGVyID0+IHtcbiAgICAgICAgICAgIGNvdW50ZXIuY291bnQgPSAwO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWdpc3RlclJlbmRlckNvdW50ZXIobmFtZSwgdmFsKSB7XG4gICAgbGV0IGNvdW50ZXJzID0gcmVuZGVyQ291bnRlclJlZ2lzdHJ5LmdldChuYW1lKTtcbiAgICBpZiAoY291bnRlcnMgPT0gbnVsbCkge1xuICAgICAgICBjb3VudGVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcmVuZGVyQ291bnRlclJlZ2lzdHJ5LnNldChuYW1lLCBjb3VudGVycyk7XG4gICAgfVxuICAgIGNvdW50ZXJzLmFkZCh2YWwpO1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVuZGVyQ291bnRlcihuYW1lLCB2YWwpIHtcbiAgICBjb25zdCBjb3VudGVycyA9IHJlbmRlckNvdW50ZXJSZWdpc3RyeS5nZXQobmFtZSk7XG4gICAgaWYgKGNvdW50ZXJzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb3VudGVycy5kZWxldGUodmFsKTtcbn1cbmZ1bmN0aW9uIHVzZVJlbmRlckNvdW50ZXIobmFtZSkge1xuICAgIGNvbnN0IHZhbCA9IHVzZVJlZihudWxsKTtcbiAgICBpZiAodmFsLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICB2YWwuY3VycmVudC5jb3VudCArPSAxO1xuICAgIH1cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodmFsLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY291bnRlciA9IHsgY291bnQ6IDAgfTtcbiAgICAgICAgICAgIHJlZ2lzdGVyUmVuZGVyQ291bnRlcihuYW1lLCBjb3VudGVyKTtcbiAgICAgICAgICAgIHZhbC5jdXJyZW50ID0gY291bnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbC5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlUmVuZGVyQ291bnRlcihuYW1lLCB2YWwuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5jb25zdCBzZWVuRXJyb3JzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gJHN0cnVjdHVyYWxDaGVjayhvbGRWYWx1ZSwgbmV3VmFsdWUsIHZhcmlhYmxlTmFtZSwgZm5OYW1lLCBraW5kLCBsb2MpIHtcbiAgICBmdW5jdGlvbiBlcnJvcihsLCByLCBwYXRoLCBkZXB0aCkge1xuICAgICAgICBjb25zdCBzdHIgPSBgJHtmbk5hbWV9OiR7bG9jfSBbJHtraW5kfV0gJHt2YXJpYWJsZU5hbWV9JHtwYXRofSBjaGFuZ2VkIGZyb20gJHtsfSB0byAke3J9IGF0IGRlcHRoICR7ZGVwdGh9YDtcbiAgICAgICAgaWYgKHNlZW5FcnJvcnMuaGFzKHN0cikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWVuRXJyb3JzLmFkZChzdHIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKHN0cik7XG4gICAgfVxuICAgIGNvbnN0IGRlcHRoTGltaXQgPSAyO1xuICAgIGZ1bmN0aW9uIHJlY3VyKG9sZFZhbHVlLCBuZXdWYWx1ZSwgcGF0aCwgZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID4gZGVwdGhMaW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZFZhbHVlID09PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvbGRWYWx1ZSAhPT0gdHlwZW9mIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBlcnJvcihgdHlwZSAke3R5cGVvZiBvbGRWYWx1ZX1gLCBgdHlwZSAke3R5cGVvZiBuZXdWYWx1ZX1gLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9sZFZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgb2xkQXJyYXkgPSBBcnJheS5pc0FycmF5KG9sZFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gQXJyYXkuaXNBcnJheShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgPT09IG51bGwgJiYgbmV3VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignbnVsbCcsIGB0eXBlICR7dHlwZW9mIG5ld1ZhbHVlfWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoYHR5cGUgJHt0eXBlb2Ygb2xkVmFsdWV9YCwgJ251bGwnLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIGlmICghKG5ld1ZhbHVlIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgTWFwIGluc3RhbmNlYCwgYG90aGVyIHZhbHVlYCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZS5zaXplICE9PSBuZXdWYWx1ZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGBNYXAgaW5zdGFuY2Ugd2l0aCBzaXplICR7b2xkVmFsdWUuc2l6ZX1gLCBgTWFwIGluc3RhbmNlIHdpdGggc2l6ZSAke25ld1ZhbHVlLnNpemV9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2Ygb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV3VmFsdWUuaGFzKGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoYE1hcCBpbnN0YW5jZSB3aXRoIGtleSAke2t9YCwgYE1hcCBpbnN0YW5jZSB3aXRob3V0IGtleSAke2t9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXIodiwgbmV3VmFsdWUuZ2V0KGspLCBgJHtwYXRofS5nZXQoJHtrfSlgLCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBlcnJvcignb3RoZXIgdmFsdWUnLCBgTWFwIGluc3RhbmNlYCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShuZXdWYWx1ZSBpbnN0YW5jZW9mIFNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoYFNldCBpbnN0YW5jZWAsIGBvdGhlciB2YWx1ZWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUuc2l6ZSAhPT0gbmV3VmFsdWUuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgU2V0IGluc3RhbmNlIHdpdGggc2l6ZSAke29sZFZhbHVlLnNpemV9YCwgYFNldCBpbnN0YW5jZSB3aXRoIHNpemUgJHtuZXdWYWx1ZS5zaXplfWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZS5oYXModikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihgU2V0IGluc3RhbmNlIHdpdGhvdXQgZWxlbWVudCAke3Z9YCwgYFNldCBpbnN0YW5jZSB3aXRoIGVsZW1lbnQgJHt2fWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ290aGVyIHZhbHVlJywgYFNldCBpbnN0YW5jZWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9sZEFycmF5IHx8IG5ld0FycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEFycmF5ICE9PSBuZXdBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgdHlwZSAke29sZEFycmF5ID8gJ2FycmF5JyA6ICdvYmplY3QnfWAsIGB0eXBlICR7bmV3QXJyYXkgPyAnYXJyYXknIDogJ29iamVjdCd9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZS5sZW5ndGggIT09IG5ld1ZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgYXJyYXkgd2l0aCBsZW5ndGggJHtvbGRWYWx1ZS5sZW5ndGh9YCwgYGFycmF5IHdpdGggbGVuZ3RoICR7bmV3VmFsdWUubGVuZ3RofWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBvbGRWYWx1ZS5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3VyKG9sZFZhbHVlW2lpXSwgbmV3VmFsdWVbaWldLCBgJHtwYXRofVske2lpfV1gLCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQob2xkVmFsdWUpIHx8IGlzVmFsaWRFbGVtZW50KG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChvbGRWYWx1ZSkgIT09IGlzVmFsaWRFbGVtZW50KG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgdHlwZSAke2lzVmFsaWRFbGVtZW50KG9sZFZhbHVlKSA/ICdSZWFjdCBlbGVtZW50JyA6ICdvYmplY3QnfWAsIGB0eXBlICR7aXNWYWxpZEVsZW1lbnQobmV3VmFsdWUpID8gJ1JlYWN0IGVsZW1lbnQnIDogJ29iamVjdCd9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZS50eXBlICE9PSBuZXdWYWx1ZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGBSZWFjdCBlbGVtZW50IG9mIHR5cGUgJHtvbGRWYWx1ZS50eXBlfWAsIGBSZWFjdCBlbGVtZW50IG9mIHR5cGUgJHtuZXdWYWx1ZS50eXBlfWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3VyKG9sZFZhbHVlLnByb3BzLCBuZXdWYWx1ZS5wcm9wcywgYFtwcm9wcyBvZiAke3BhdGh9XWAsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoYG9iamVjdCB3aXRob3V0IGtleSAke2tleX1gLCBgb2JqZWN0IHdpdGgga2V5ICR7a2V5fWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihgb2JqZWN0IHdpdGgga2V5ICR7a2V5fWAsIGBvYmplY3Qgd2l0aG91dCBrZXkgJHtrZXl9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXIob2xkVmFsdWVba2V5XSwgbmV3VmFsdWVba2V5XSwgYCR7cGF0aH0uJHtrZXl9YCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2xkVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc05hTihvbGRWYWx1ZSkgfHwgaXNOYU4obmV3VmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4ob2xkVmFsdWUpICE9PSBpc05hTihuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihgJHtpc05hTihvbGRWYWx1ZSkgPyAnTmFOJyA6ICdub24tTmFOIHZhbHVlJ31gLCBgJHtpc05hTihuZXdWYWx1ZSkgPyAnTmFOJyA6ICdub24tTmFOIHZhbHVlJ31gLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBlcnJvcihvbGRWYWx1ZSwgbmV3VmFsdWUsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWN1cihvbGRWYWx1ZSwgbmV3VmFsdWUsICcnLCAwKTtcbn1cblxuZXhwb3J0cy4kZGlzcGF0Y2hlckd1YXJkID0gJGRpc3BhdGNoZXJHdWFyZDtcbmV4cG9ydHMuJG1ha2VSZWFkT25seSA9ICRtYWtlUmVhZE9ubHk7XG5leHBvcnRzLiRyZXNldCA9ICRyZXNldDtcbmV4cG9ydHMuJHN0cnVjdHVyYWxDaGVjayA9ICRzdHJ1Y3R1cmFsQ2hlY2s7XG5leHBvcnRzLmMgPSBjO1xuZXhwb3J0cy5jbGVhclJlbmRlckNvdW50ZXJSZWdpc3RyeSA9IGNsZWFyUmVuZGVyQ291bnRlclJlZ2lzdHJ5O1xuZXhwb3J0cy5yZW5kZXJDb3VudGVyUmVnaXN0cnkgPSByZW5kZXJDb3VudGVyUmVnaXN0cnk7XG5leHBvcnRzLnVzZVJlbmRlckNvdW50ZXIgPSB1c2VSZW5kZXJDb3VudGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-compiler-runtime@0.0.0-experimental-22c6e49-20241219_react@19.0.0/node_modules/react-compiler-runtime/dist/index.js\n");

/***/ })

};
;